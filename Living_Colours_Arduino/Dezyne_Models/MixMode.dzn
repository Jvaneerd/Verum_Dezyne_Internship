import RGBLed.dzn;

interface IMixMode {
	in void start();
	in void stop();
	in void toggle();
	
	behaviour {
		bool isRunning = false;
		on start: {
			[!isRunning] isRunning = true;
			[isRunning] illegal;
		}
		on stop: {
			[!isRunning] illegal;
			[isRunning] isRunning = false;
		}
		on toggle: {
			[!isRunning] illegal;
			[isRunning] {}
		}
	}
} 

interface IHWMixer {
	in void start();
	in void stop();
	in void mixRed();
	in void mixGreen();
	in void mixBlue();
	
	out void valueChanged(Integer newValue);
	behaviour {
		on start: {}
		on stop: {}
		
		on mixRed: {}
		on mixGreen: {}
		on mixBlue: {}
	}
}

component MixMode {
	provides IMixMode iMixMode;
	requires IHWMixer iHWMixer;
	requires IRGBLed iRGBLed;

	behaviour {
		enum State { MixingRed, MixingGreen, MixingBlue };
		bool isRunning = false;
		State state = State.MixingRed;
		
		on iMixMode.start(): {
			[!isRunning] { 
				iHWMixer.start();
				isRunning = true;
			}
		} 
		
		[isRunning] {
			on iMixMode.toggle(): {
				[state == State.MixingRed] {
					iHWMixer.mixGreen();
					state = State.MixingGreen;
				}
				[state == State.MixingGreen] {
					iHWMixer.mixBlue();
					state = State.MixingBlue;
				}
				[state == State.MixingBlue] {
					iHWMixer.mixRed();
					state = State.MixingRed;
				}
			} 
			
			on iHWMixer.valueChanged(newValue): {
				[state == State.MixingRed] {
					iRGBLed.setSpecificRed(newValue);
				} 
				[state == State.MixingGreen] {
					iRGBLed.setSpecificGreen(newValue);
				} 
				[state == State.MixingBlue] {
					iRGBLed.setSpecificBlue(newValue);
				}
			} 
			
			on iMixMode.stop(): {
				iHWMixer.stop();
				isRunning = false;
			}
		}
	}
}